package Graphs.lecture6;

import java.util.HashMap;

public class MaximumMalwareSpread_DSU_UnionBySIze {
    // can be solved via DFS or DSU but we are using DSU becuase here DSU union by size is included

    // in this question the question humse maang raha hai ki bhai humne tumhe different connected components de rkhe hai of disconnected graph
    // and tumhe uss component me kuch kuch nodes initially infected hai hume return karna hai hum konsi "ek" node ko cure karde jisse hmara answer aaye jisme maximum nodes save ho rhi ho and hume uss answer
    // me agar do values par hum 3-3 nodes save kar rhe hai to hume usme se vo node return karni hai  jiski value kam ho
    int[] par;
    int[] size;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        par = new int[n];
        size = new int[n];
        HashMap<Integer, Integer> map = new HashMap<>();

        // initialise the par array and size array
        for (int i = 0; i < n; i++) {
            par[i] = i;
            size[i] = 1;
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 1) {
                    union(i, j);
                }
            }
        }

        // preparing the hashmap of infected by iterating over the infected array
        for (int i = 0; i < initial.length; i++) {
            int parofcurrinfected = find(initial[i]);
            if (map.containsKey(parofcurrinfected)) {
                map.put(parofcurrinfected, map.get(parofcurrinfected) + 1);
            } else {
                map.put(parofcurrinfected, 1);
            }
        }

        // iterating over the infected array and cvount the number of nodes which can be saved may
        int ans = -1;
        int count = -1;
        for (int i = 0; i < initial.length; i++) {
            int parofcurrinfected = find(initial[i]);
            int sizeofcurrinfectedparent = size[parofcurrinfected];
            int totalinfectedinthatcomp = map.get(parofcurrinfected);

            // agar uss particular component me do ya do se jyada infected hai to directly size ko 0 kardo taaki sirf hum nodes ke value ka comparison kare kyu hum ek hi node hata sakte hai and hume answer jo bhej rhe hai uski bhi sabse least value bhejni hai
            if (totalinfectedinthatcomp >= 2) {
                sizeofcurrinfectedparent = 0;
            }
            if (count == sizeofcurrinfectedparent) {
                // yaha par hum initial se competition issiliye karvaenge hume uss node ke parents nahi bhejne hai balki jo node infected hai uss node ko cure karke jiski value sabse minimum hai use as a answer bhejna hai
                if (ans > initial[i]) {
                    ans = initial[i];
                }
            } else if (count < sizeofcurrinfectedparent) {
                ans = initial[i];
                count = sizeofcurrinfectedparent;
            }

        }
        return ans;
    }

    public int find(int x) {
        if (par[x] == x) return x;

        int temp = find(par[x]);

        return par[x] = temp;
    }

    public void union(int x, int y) {
        int lx = find(x);
        int ly = find(y);

        if (ly != lx) {
            if (size[lx] > size[ly]) {
                par[ly] = lx;
                size[lx] += size[ly];
            } else if (size[lx] < size[ly]) {
                par[lx] = ly;
                size[ly] += size[lx];
            } else {
                par[lx] = ly;
                size[ly] += size[lx];
            }
        }
    }
}